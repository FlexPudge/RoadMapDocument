Поразрядные операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами. Но сначала вкратце рассмотрим, что представляют собой разряды чисел.

**Двоичное представление чисел**

На уровне компьютера все данные представлены в виде набора бит. Каждый бит может иметь два значения: 1 (есть сигнал) и 0 (нет сигнала). И все данные фактически представляют набор нулей и единиц. 8 бит представляют 1 байт. Подобную систему называют двоичной.

```
// перевод десятичного числа 13 в двоичную систему
13 / 2 = 6      // остаток 1 (13 - 6 *2 = 1)
6 / 2 = 3      // остаток 0 (6 - 3 *2 = 0)
3 / 2 = 1      // остаток 1 (3 - 1 *2 = 1)
1 / 2 = 0      // остаток 1 (1 - 0 *2 = 1)
```

Общий алгоритм состоит в последовательном делении числа и результатов деления на 2 и получение остатков, пока не дойдем до 0. Затем выстраиваем остатки в линию в обратном порядке и таким образом формируем двоичное представление числа. Конкретно в данном случае по шагам:

1. Делим число 13 на 2. Результат деления - 6, остаток от деления - 1 (так как 13 - 6 *2 = 1)
2. Далее делим результат предыдущей операции деления - число 6 на 2. Результат деления - 3, остаток от деления - 0
3. Делим результат предыдущей операции деления - число 3 на 2. Результат деления - 1, остаток от деления - 1
4. Делим результат предыдущей операции деления - число 1 на 2. Результат деления - 0, остаток от деления - 1
5. Последний результат деления равен 0, поэтому завершаем процесс и выстраиваем остатки от операций делений, начиная с последнего - `1101`

При обратном переводе из двоичной системы в десятичную умножаем значение каждого бита (1 или 0) на число 2 в степени, равной номеру бита (нумерация битов идет от нуля):
```
// перевод двоичного числа 1101 в десятичную систему
1(3-й бит)1(2-й бит)0(1-й бит)1(0-й бит)
1 * 23 + 1 * 22 + 0 * 21 + 1 * 20
=
1 * 8 + 1 * 4 + 0 * 2 + 1 * 1
=
8 + 4 + 0 + 1 
=
13
```

**Представление отрицательных чисел**

Для записи чисел со знаком в С++ применяется дополнительный код (two's complement), при котором старший разряд является знаковым. Если его значение равно 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. Например, 0000 0001 в десятичной системе 1.

Если старший разряд равен 1, то мы имеем дело с отрицательным числом. Например, 1111 1111 в десятичной системе представляет -1. Соответственно, 1111 0011 представляет -13.

Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу.

**Опции сдвига**

Каждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:
- **<<**
	- Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.
- **>>** 
	- Сдвигает битовое представление числа вправо на определенное количество разрядов.

```
unsigned int a = 2 << 2;			// 10  на два разрядов влево = 1000 - 8
unsigned int b = 16 >> 3;			// 10000 на три разряда вправо = 10 - 2
```

Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8.

Число 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.

Можно заметить, что сдвиг на один разряд влево фактически аналогично умножению на 2, тогда как сдвиг вправо на один раз эквивалентно делению на два. Мы можем обобщить: сдвиг влево на `n` аналогичен умножению числа на `2n`, а сдвиг вправо на `n` разрядов аналогичен делению на `2n`, что можно использовать вместо умножения/деления на степени двойки.


**Поразрядные операции**

Поразрядные операции также проводятся только над соответствующими разрядами целочисленных операндов:
- **&** (И)
	поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1
- **|** (ИЛИ)
	поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1
- **^** (исключающее ИЛИ)
	поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
- **~** (НЕ)
	поразрядное отрицание или инверсия. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.

Применение операций:
```
int a = 5 | 2;			// 101 | 010 = 111  - 7
int b = 6 & 2;			// 110 & 010 = 10  - 2
int c = 5 ^ 2;			// 101 ^ 010 = 111 - 7
int d = ~9;				// -10
```


**Приколы GCC/Clang**

**Среднее арифметическое**

```
// обычная версия 
(x + y) >> 1; 
// с защитой от переполнения суммы 
((x ^ y) >> 1) + (x & y);
```

**Умножение на 2**

```
n << 1;
```

**Деление на 2**

```
n >> 1;
```

**Проверка равенства** 

```
(a ^ b) == 0;
```

**Проверка на кратность 2** 

```
(n & 1) == 1;
```

**Смена знака** 

```
i = ~i + 1;
i = (i ^ -1) + 1;
```

**Является ли число степенью 2** 

```
x && !(x & (x - 1)); // для положительных
```
